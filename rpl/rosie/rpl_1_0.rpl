---- -*- Mode: rpl; -*-                                                                             
---- vim:syn=rosie
----
---- rpl-1.0.rpl       Rosie Pattern Language definition for Rosie Pattern Language
----
---- Â© Copyright IBM Corporation 2016, 2017.
---- LICENSE: MIT License (https://opensource.org/licenses/mit-license.html)
---- AUTHOR: Jamie A. Jennings

-- Requires an engine configured using the parser in parse.lua (and no macro expansion step).
-- N.B. This is written in rpl 0.0, the "rpl core" language:
--    Character set expressions are SINGLE SETS in double brackets [[set]]
--    Where 'set' is a SINGLE range, a LIST, or a NAMED SET (NOT complemented)
--    Statements supported: assignment, alias, grammar
--    Operators supported: sequence (adjacency), choice (/), raw ({}), cooked (())
--    Predicates supported: negation (!), look-ahead (@)
--    Repetition supported: star, plus, question, and {n,m}
--    AND compilation is done in sequence, top to bottom, so bindings must be ordered

package rpl_1_0

alias newline = [[\n]]

alias comment = { "--" {!newline .}* {newline / $} }
alias ignore = { { [[:space:]] / comment }* }

alias id_char = { [[:alnum:]] / [[_]] }
alias id = { [[:alpha:]] id_char* }

identifier = { { id {[[.]]id}* } -- hierarchical identifier name
	       / [[.]]		 -- a single dot
	       / [[$]]		 -- a single dollar sign
	       / [[~]]		 -- a single tilde
	    }

alias dquote = { [[\"]] }
alias esc =    { [[\\]] }
literal = { {!{esc/dquote} .} / {esc .} }* 
alias quoted_string = { dquote literal dquote }

star =     { [[*]] }
question = { [[?]] }
plus =     { [[+]] }
alias end_token = { "end" !id_char }
alias keyword_list = { "alias" / "grammar" / "end" }
keyword = { keyword_list !id_char }

-- it is important that an error consume at least one character here.
-- as a tactic for continuing to parse after an error , we will skip to eol and try to continue. 
rest_of_line = { {!newline .}+ ignore }
syntax_error = { rest_of_line }

complement = "^"
character = { {!esc !"[" !"^" !"]" .} / {esc .} }
range = { complement? character [[-]] !"]" character } 
charlist = { complement? {!"]" character}+ }		    -- cannot be empty
name = {!":" .}+
named_charset = { complement? name } 
alias one_charset = { "[" { ":" named_charset ":]" } /
	                  { range "]" } /
		          { charlist "]" } /
		          syntax_error
		    }
charset_exp = { "[" complement? ignore (one_charset ignore)+ "]" } / one_charset

low =  [[:digit:]]*				    -- an int or nothing
high = [[:digit:]]* 
repetition = { "{" ignore low ignore "," ignore high ignore "}" }

alias quantifier = star / question / plus / repetition

assignment_prefix = identifier ignore "="
statement_prefix = {keyword / assignment_prefix}

alias slash =         { [[/]] }
alias open =          { [[(]] }
alias openraw =       { [[{]] }
alias close =         { [[)]] }
alias closeraw =      { [[}]] }

negation = { [[!]] }
lookat = { [[@]] }
alias predicate_symbol = { negation / lookat }
	    
grammar
   alias expression = {ignore { syntax_error / choice / sequence / quantified_exp / plain_exp} }
   syntax_error = { statement_prefix rest_of_line }
   choice = { {quantified_exp / plain_exp} ignore slash expression }
   sequence = { {quantified_exp / plain_exp} {ignore !statement_prefix expression}+ }
   alias plain_exp = { ignore 
		       { identifier / quoted_string / raw / cooked / charset_exp / predicate } }
   quantified_exp = { plain_exp ignore quantifier }
   cooked = { open expression+ ignore close }
   raw = { openraw expression+ ignore closeraw }
   predicate = { predicate_symbol ignore {quantified_exp / plain_exp} }
end

grammar
   alias statement = { alias_ / grammar_ / assignment_ }
   alias_ = { "alias" ignore identifier ignore "=" expression }
   grammar_ = { "grammar" { ignore { alias_ / assignment_ } }+ ignore end_token }
   assignment_ = { identifier ignore "=" expression }
end

major = [[0-9]]{1,2}
minor = major
version_spec = { major "." minor {[[:space:]]/$}}	    -- core lacks ~
preparse = ignore "rpl" (version_spec / syntax_error)

-- we fake-parse a package declaration, which is not part of rpl 1.0.
-- this makes it possible to put a package declaration in rpl_1_1.rpl.
alias package_decl = {"package" [[:space:]]} {!newline .}*

rpl_statements = (ignore statement / package_decl / syntax_error)* ignore $
rpl_expression = ignore expression ignore $

--alias item = {ignore {statement / expression / syntax_error}}
--rpl = item* ignore $
