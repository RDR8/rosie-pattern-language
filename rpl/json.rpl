---- -*- Mode: rpl; -*-                                                                             
----
---- json.rpl    some rpl patterns for processing json input
----
---- Â© Copyright IBM Corporation 2016.
---- LICENSE: MIT License (https://opensource.org/licenses/mit-license.html)
---- AUTHOR: Jamie A. Jennings


---------------------------------------------------------------------------------------------------
-- The rpl definition 'json' matches JSON input and returns it as a monolithic entity with no
-- sub-matches at all.
--
-- If you want Rosie to parse out some individual JSON values, you can do this by:
-- (1) Selectively removing 'alias' in some definitions, and/or
-- (2) Adding some definitions of your own to create Rosie captures, as we did below by defining
-- 'json' to be a capturing version of 'json.json_discard'.
--
-- Note: There are simpler ways of matching an entire JSON input string in the case where validation
-- is not necessary.  Simply matching text with balanced [] and {} pairs will consume JSON arrays
-- and objects, respectively.
--
-- When matching against the 'json' pattern at the command line, use the -nocolor switch to output
-- the JSON itself.  Or use the -json switch to produce the usual Rosie json structure.  The 'text'
-- field will contain the matched (JSON) string from the input, as always.
---------------------------------------------------------------------------------------------------

alias json.string = common.escaped_string
alias json.number = common.signed_number

alias json.true = "true"
alias json.false = "false"
alias json.null = "null"

-- Here are two examples of JSON grammars.  The first, json.discard, matches JSON input but discards
-- all the submatches.  If you need to match a JSON structure within some larger input, and capture
-- it for later processing (including JSON decoding), then this is a convenient and efficient way to
-- do it.
-- 
-- The second grammar, json.json, includes all the submatches.  You can walk through the output,
-- doing whatever needs to be done with each json.object, json.array, etc.

grammar
   alias json.discard = ~ json.value
   alias json.value = json.string / json.number / json.object / json.array / json.true / json.false / json.null
   alias json.member = json.string ":" json.value
   alias json.object = "{" (json.member ("," json.member)*)? "}"
   alias json.array = "[" (json.value ("," json.value)*)? "]"
end

grammar
   alias json.json = ~ json.value
   alias json.value = json.string / json.number / json.object / json.array / json.true / json.false / json.null
   json.member = json.string ":" json.value
   json.object = "{" (json.member ("," json.member)*)? "}"
   json.array = "[" (json.value ("," json.value)*)? "]"
end

---------------------------------------------------------------------------------------------------
--
-- Match against 'json.discard' to capture a single json value with no submatches.  This is
-- useful to simply eat up the JSON piece of a larger input, capturing it for later processing.
--
-- Match against 'json.json' to capture a single json value and keep all the submatches of
-- individual members and values.



