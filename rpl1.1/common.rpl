---- -*- Mode: rpl; -*-                                                                             
---- vim:syn=rosie
----
---- common.rpl   Common patterns in Rosie Pattern Language
----
---- Â© Copyright IBM Corporation 2016, 2017.
---- LICENSE: MIT License (https://opensource.org/licenses/mit-license.html)
---- AUTHOR: Jamie A. Jennings

package common

alias any = .
alias whitespace = [:space:]
alias digit = [:digit:]
alias letter = [:alpha:]

-- [:graph:] won't match unicode, but these will:
alias graph = {![:space:] .}
alias id_char = [_-] / {![:space:] ![:punct:] .}
-- test id_char accepts "_", "-", "i", "3"
-- test id_char rejects "#", "%", "`"

alias hex_only = { [a-f] / [A-F] }
alias hex_digits = { digit / [a-f] / [A-F] }
--alias hex = { digit hex_digits+ } / { hex_only+ digit hex_digits* }
int = { [+-]? digit+ !hex_only}	     -- at least one digit, and not a hex number
-- test int accepts "34", "+34", "-34"
-- test int rejects "BEEF", "0x20"
float = { [+-]? digit+ "." digit+ }  -- float with digits on either side of radix
-- test float accepts "1.23", "+1.23", "-1.23"
-- test float rejects "12", "bob", "1."
hex = hex_digits+ 		     --  use with care! will match words and decimal numbers
-- test hex accepts "BEEF", "f4c3b00c"
-- test hex rejects "0xBEEF", "Facebook"
denoted_hex = { "0x" hex }
-- test denoted_hex accepts "0xBEEF", "0x20"
-- test denoted_hex rejects "BEEF", "0x2o"
number =  (denoted_hex /  float / int / hex)

word = letter+
-- test word accepts "foo"
-- test word rejects "12356", "  ", "#!", "ac475"

-- This definition is essentially what grok uses, which isn't great:
-- unix_path = { "/" ([:alnum:]/[_%!$@:.,~-])+ / ".." / "." }+

alias unix_path = { {".." / "."}? {"/" {[:alnum:]/[_%!$@:.,~-]}+ }+  }
--alias pathchar = [[:alnum:][_%!$@:.,~-]]
--alias unix_path = { {"../" / "./" / "/"}? {pathchar+ {"/" pathchar+}+ } }
alias windows_path = { {[:alpha:]+ ":"}? {"\\" {![\\?*] any}* }+ }
path = unix_path / windows_path

alias dash_under = [-_]

alias identifier_char = { letter / digit / "_" }
alias identifier_plus_char = { letter / digit / dash_under / "$" }

identifier = {letter identifier_char*}
identifier_plus = {letter identifier_plus_char*}

alias identifier_plus_plus1 = { { {letter / dash_under / "$"} identifier_plus_char*} }
alias identifier_plus_plus2 = {digit+ identifier_plus_char*} -- FIXME: I match integers!
identifier_plus_plus = identifier_plus_plus1 / identifier_plus_plus2

dotted_identifier = { identifier_plus_plus { "." identifier_plus_plus}+ }

-- starts with a letter and contains a digit, or starts with a letter
--and contains a dash/under (otherwise, all the identifier_plus
--characters are allowed) 
identifier_not_word = { {letter {letter / dash_under}* [:digit:] identifier_plus_char*}
                               / {letter {letter / digit}* dash_under identifier_plus_char*} }

-- Upper case words which may also contain digits, dashes,
-- underlines. Note that we explicitly fail if the first upper case
-- letter is followed by a lower case one, since most sentences and
-- proper names start that way.
maybe_identifier = { [:upper:] ![:lower:] {[:upper:] / [:digit:] / dash_under}* }

alias h = [:xdigit:]
alias type4_guid_nocap = {h{8,8} "-" {h{4,4} "-"}{3,3} h{12,12}}
type4_guid = type4_guid_nocap

-- Quoted strings, using single or double quote
--
-- Within a string, the quote character can be escaped using a slash, OR by repeating it twice,
-- e.g. "".
alias dquoted_string = "\""  {"\\\"" / {! [\"] .}}* "\""

alias dquote = "\""			      -- "
alias escaped_dquote = "\\\"" / "\\\"\\\"" / "\"\"" -- \" or \"\" or "" 
alias squote = "'"			      -- '
alias escaped_squote = "\\'" / "\\'\\'" / "''"      -- \' or \'\' or ''
-- Capture the contents of a quoted field by assigning it to an RPL name:
double_quoted_field = {escaped_dquote / {!dquote .}}*
single_quoted_field = {escaped_squote / {!squote .}}*

-- Wrap the field contents with quotation marks:
alias dq = {dquote double_quoted_field dquote}
alias sq = {squote single_quoted_field squote}

-- Look for either double or single quoted fields
quoted_field = dq / sq

