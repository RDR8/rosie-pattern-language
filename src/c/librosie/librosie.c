/*  -*- Mode: C/l; -*-                                                       */
/*                                                                           */
/* librosie.c    Expose the Rosie API                                        */
/*                                                                           */
/*  Â© Copyright IBM Corporation 2016.                                        */
/*  LICENSE: MIT License (https://opensource.org/licenses/mit-license.html)  */
/*  AUTHOR: Jamie A. Jennings                                                */


/* ROSIE_HOME defined on the command line during compilation (see Makefile)  */

#ifndef ROSIE_HOME
#error "ROSIE_HOME not defined.  Check CFLAGS in Makefile?"
#endif

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include "lauxlib.h"
#include "lualib.h"

#include "librosie.h"

static lua_State *LL = NULL;
static const char *progname = "librosie";

/*
 * Hook set by signal function to stop the interpreter.
 */
/* static void lstop (lua_State *L, lua_Debug *ar) { */
/*   (void)ar;  /\* unused arg. *\/ */
/*   lua_sethook(L, NULL, 0, 0);  /\* reset hook *\/ */
/*   luaL_error(L, "interrupted!"); */
/* } */

/*
 * Function to be called at a C signal. Because a C signal cannot
 * just change a Lua state (as there is no proper synchronization),
 * this function only sets a hook that, when called, will stop the
 * interpreter.
 */
/* static void laction (int i) { */
/*   signal(i, SIG_DFL); /\* if another SIGINT happens, terminate process *\/ */
/*   lua_sethook(LL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1); */
/* } */

/*
 * Prints an error message, adding the program name in front of it
 * (if present)
 */
void l_message (const char *pname, const char *msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}

/*
 * Check whether 'status' is not OK and, if so, prints the error
 * message on the top of the stack. It assumes that the error object
 * is a string, as it was either generated by Lua or by 'msghandler'.
 */
/* static int report (lua_State *L, int status) { */
/*   if (status != LUA_OK) { */
/*     const char *msg = lua_tostring(L, -1); */
/*     l_message(progname, msg); */
/*     lua_pop(L, 1);  /\* remove message *\/ */
/*   } */
/*   return status; */
/* } */

/*
 * Message handler used to run all chunks
 */
static int msghandler (lua_State *L) {
  const char *msg = lua_tostring(L, 1);
  if (msg == NULL) {  /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
      return 1;  /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                               luaL_typename(L, 1));
  }
  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
  return 1;  /* return the traceback */
}

/*
 * Interface to 'lua_pcall', which sets appropriate message function
 * and C-signal handler. Used to run all chunks.
 */
static int docall (lua_State *L, int narg, int nres) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, msghandler);  /* push message handler */
  lua_insert(L, base);  /* put it under function and args */
  /* signal(SIGINT, laction);  /\* set C-signal handler *\/ */
  status = lua_pcall(L, narg, nres, base);
  /* signal(SIGINT, SIG_DFL); /\* reset C-signal handler *\/ */
  lua_remove(L, base);  /* remove message handler from the stack */
  return status;
}

#if 0
static int dochunk (lua_State *L, int status) {
  if (status == LUA_OK) status = docall(L, 0, 0);
  return report(L, status);
}

static int dofile (lua_State *L, const char *name) {
  return dochunk(L, luaL_loadfile(L, name));
}

static int dostring (lua_State *L, const char *s, const char *name) {
  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));
}
#endif

static void stackDump (lua_State *L) {
      int i;
      int top = lua_gettop(L);
      if (top==0) { printf("EMPTY STACK\n"); return;}
      for (i = top; i >= 1; i--) {
        int t = lua_type(L, i);
        switch (t) {
    
          case LUA_TSTRING:  /* strings */
	       printf("%d: '%s'", i, lua_tostring(L, i));
            break;
    
          case LUA_TBOOLEAN:  /* booleans */
	       printf("%d: %s", i, (lua_toboolean(L, i) ? "true" : "false"));
            break;
    
          case LUA_TNUMBER:  /* numbers */
	       printf("%d: %g", i, lua_tonumber(L, i));
            break;
    
          default:  /* other values */
	       printf("%d: %s", i, lua_typename(L, t));
            break;
    
        }
        printf("  ");  /* put a separator */
      }
      printf("\n");  /* end the listing */
    }

#define SET_ROSIE_HOME(val) SET_ROSIE_HOME_HELPER(val)
#define SET_ROSIE_HOME_HELPER(thing) QUOTE(ROSIE_HOME = #thing)

#define QUOTE_EXPAND(name) QUOTE(name)		    /* expand name */
#define QUOTE(thing) #thing			    /* stringify it */

#define MAXPATHSIZE 4096
int bootstrap (const char *rosie_home) {
     char name[MAXPATHSIZE + 1];
     if (strlcpy(name, rosie_home, sizeof(name)) >= sizeof(name))
	  luaL_error(LL, "error during bootstrap: MAXPATHSIZE too small");
     if (strlcat(name, "/src/bootstrap.lua", sizeof(name)) >= sizeof(name))
	  luaL_error(LL, "error during bootstrap: MAXPATHSIZE too small");
     return luaL_dofile(LL, name);
}

void require (const char *name, int assign_name) {  
     int status;  
     lua_getglobal(LL, "require");  
     lua_pushstring(LL, name);  
     status = docall(LL, 1, 1);                   /* call 'require(name)' */  
     if (status != LUA_OK) {  
	  l_message(progname, lua_pushfstring(LL, "error requiring %s (%s)", name, lua_tostring(LL, -1)));  
	  exit(-1);  
     }  
     if (assign_name==TRUE) lua_setglobal(LL, name); /* set the global to the return value of 'require' */  
     else lua_pop(LL, 1);    /* else discard the result of require */  
}  

void initialize(const char *rosie_home) {
     int status;
     lua_State *L = luaL_newstate();
     if (L == NULL) {
	  l_message((char *)'\0', "error during initialization: not enough memory");
	  exit(-2);
     }
     LL = L;
/* 
   luaL_checkversion checks whether the core running the call, the core that created the Lua state,
   and the code making the call are all using the same version of Lua. Also checks whether the core
   running the call and the core that created the Lua state are using the same address space.
*/   
  luaL_checkversion(L);
  luaL_openlibs(L);		/* open standard libraries */
  int stkpos = lua_gettop(L);
  lua_pushstring(L, rosie_home);
  lua_setglobal(L, "ROSIE_HOME");
  LOGf("Initializing Rosie, where ROSIE_HOME = %s\n", rosie_home);
  status = bootstrap(rosie_home);
  if (status != LUA_OK) exit(-1); 
  require("repl", FALSE);
  require("api", TRUE);
  if (lua_gettop(L)!=stkpos)
       printf("WARNING: after initialization, top should be %d but was %d\n",
	      stkpos,
	      lua_gettop(L));
}

uint32_t testbyvalue(struct string foo) {
     printf("testbyvalue: len=%d, string=%s\n", foo.len, foo.ptr);
     return (uint32_t) strlen((const char *)foo.ptr);
}

uint32_t testbyref(struct string *foo) {
     printf("testbyref: len=%d, string=%s\n", foo->len, foo->ptr);
     return (uint32_t) strlen((const char *)foo->ptr);
}

struct string testretstring(struct string *foo) {
     printf("testbyref: len=%d, string=%s\n", foo->len, foo->ptr);
     char *msg = "This is a new struct string returned from librosie.";
     size_t len = (size_t) strlen(msg);
     uint8_t *ptr = malloc(len+1);                /* to return a string, we must make */
     strlcpy((char *)ptr, msg, len);              /* sure it is allocated on the heap */
     struct string bar = (struct string) {len, ptr};
     return bar;
}

struct string *heap_allocate_string(const char *msg) {
     size_t len = (size_t) strlen(msg);
     uint8_t *ptr = malloc(len+1);     /* to return a string, we must make */
     strlcpy((char *)ptr, msg, len+1); /* sure it is allocated on the heap */
     struct string *retval = malloc(sizeof(struct string));
     struct string bar = (struct string) {len, ptr};
     memcpy(retval, &bar, sizeof(bar));
     return retval;
}     

struct stringArray testretarray(struct string foo) {
     printf("testretarray argument received: len=%d, string=%s\n", foo.len, foo.ptr);

     struct string *b = heap_allocate_string("This is a new struct string called b.");
     struct string *c = heap_allocate_string("This is a new struct string called c.");
     struct string *d = heap_allocate_string("This is a new struct string called d.");
     struct string **ptr = malloc(sizeof(struct string *) * 3);
     ptr[0] = b; ptr[1] = c; ptr[2] = d;

     return (struct stringArray) {3, ptr};

}

void free_string(struct string foo) FREE_STRING(foo);
void free_stringArray(struct stringArray r) {
     struct string *s = *r.ptr;
     for (uint32_t i=0; i<r.n; i++) {
	  free_string(*s);
	  s++;
     }
     r.n=0;
}

struct stringArray rosie_api(const char *name, ...) {

     va_list args;
     struct string *arg;
     int base;
     
     lua_State *L = LL;

     /* number of args AFTER the api name */
     int nargs = 2;		   /* get this later from a table */

     /* printf("Calling Rosie api: %s\n", name); */

     va_start(args, name);	   /* setup variadic arg processing */

     LOGf("Stack at start of rosie_api (%s):\n", name);
     LOGstack(L);
     base = lua_gettop(L);			    /* save top pointer */
     /* printf("Base of stack is %d\n", base); */

     /* Optimize later: memoize stack value of fcn for each api call to avoid this lookup? */

     lua_getglobal(L, "api");
     lua_getfield(L, -1 , name);                    /* -1 is stack top, i.e. api table */

     lua_remove(L, -2);	    /* remove the api table from the stack */ 
     /* Later: insert a check HERE to ensure the value we get is a function */

     for (int i = 1; i <= nargs; i++) {
	  arg = va_arg(args, struct string *); /* get the next arg */
	  /* printf("LUA stack pushlstring: len=%d, value=%s\n", arg->len, arg->ptr);  */
	  lua_pushlstring(L, (char *) arg->ptr, arg->len); /* push it */
     }

     va_end(args);

     LOGf("About to call the api the function on the stack, and nargs=%d\n", nargs);  
     LOGstack(L);  

     lua_call(L, nargs, 1); 

     LOG("Stack immediately after lua_call:\n");
     LOGstack(L);
     
     if (lua_istable(L, base+1) != TRUE) {
	  l_message(progname, lua_pushfstring(L, "librosie internal error: return value of %s not a table", name));
	  exit(-1);
     }

     struct stringArray retvals;
     size_t nretvals = lua_rawlen(L, base+1);
     struct string **list = malloc(sizeof(struct string *) * nretvals);
     size_t len;
	  
     for (size_t i=0; i<nretvals; i++) {
	  int t = lua_rawgeti(L, base+1, (lua_Integer) i+1); /* lua has 1-based indexing */
	  if (t != LUA_TSTRING) { printf("Return type error: %d\n", t); exit(-1); }
	  list[i] = malloc(sizeof(struct string));
	  uint8_t *str = (uint8_t *) lua_tolstring(L, -1, &len);
	  LOGf("Return value [%d]: len=%d ptr=%s\n", (int) i, (int) len, str);
	  list[i]->len = len;
	  list[i]->ptr = malloc(sizeof(uint8_t)*(len+1));
	  memcpy(list[i]->ptr, str, len);
	  list[i]->ptr[len] = 0; /* so we can use printf for debugging */	  
	  lua_pop(L, 1);
     }
     retvals.n = nretvals;
     retvals.ptr = list;

     lua_pop(L, 1);		/* pop the api call's results table */

     LOGf("Stack at end of call to Rosie api: %s\n", name); 
     LOGstack(L); 
     
     return retvals;
}


struct stringArray new_engine(struct string *config) {

     struct string *ignore = &CONST_STRING("ignored");
     struct stringArray retvals = rosie_api("new_engine", config, ignore);
     LOGf("In new_engine, number of retvals from rosie_api was %d\n", retvals.n);
     if (retvals.n !=2) {
	  l_message(progname,
		    lua_pushfstring(LL,
				    "librosie internal error: wrong number of return values to new_engine (%d)",
				    retvals.n));
	  exit(-1);
     }
     struct string *code = stringArrayRef(retvals, 0);
     char *true_value = "true";
     if (memcmp(code->ptr, true_value, (size_t) code->len)) {
	  LOGf("Success code was NOT true: len=%d, ptr=%s\n", code->len, code->ptr);
	  struct string *err = stringArrayRef(retvals,1);
	  printf("Error in new_engine: %s\n", (char *) err->ptr);
	  exit(-1);
     }
     return retvals;
}


