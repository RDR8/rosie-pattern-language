/*  -*- Mode: C/l; -*-                                                       */
/*                                                                           */
/* rosie.c      Create a Lua state, load Rosie, expose the Rosie API         */
/*                                                                           */
/*  Â© Copyright IBM Corporation 2016.                                        */
/*  LICENSE: MIT License (https://opensource.org/licenses/mit-license.html)  */
/*  AUTHOR: Jamie A. Jennings                                                */


/* 
 * Based on src/lua.c from the open source Lua 5.3.2 distribution under MIT license
 *
 * Right now, this is just hacking around to learn my way around using the Lua state.
 *
 */


#define rosie_c

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include "lauxlib.h"
#include "lualib.h"

#define PROGNAME		"rosie"

static lua_State *globalL = NULL;
static const char *progname = PROGNAME;

/*
 * Hook set by signal function to stop the interpreter.
 */
static void lstop (lua_State *L, lua_Debug *ar) {
  (void)ar;  /* unused arg. */
  lua_sethook(L, NULL, 0, 0);  /* reset hook */
  luaL_error(L, "interrupted!");
}

/*
** Function to be called at a C signal. Because a C signal cannot
** just change a Lua state (as there is no proper synchronization),
** this function only sets a hook that, when called, will stop the
** interpreter.
*/
static void laction (int i) {
  signal(i, SIG_DFL); /* if another SIGINT happens, terminate process */
  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
}

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char *pname, const char *msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message(progname, msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}

/*
** Message handler used to run all chunks
*/
static int msghandler (lua_State *L) {
  const char *msg = lua_tostring(L, 1);
  if (msg == NULL) {  /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
      return 1;  /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                               luaL_typename(L, 1));
  }
  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
  return 1;  /* return the traceback */
}

/*
** Interface to 'lua_pcall', which sets appropriate message function
** and C-signal handler. Used to run all chunks.
*/
static int docall (lua_State *L, int narg, int nres) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, msghandler);  /* push message handler */
  lua_insert(L, base);  /* put it under function and args */
  globalL = L;  /* to be available to 'laction' */
  signal(SIGINT, laction);  /* set C-signal handler */
  status = lua_pcall(L, narg, nres, base);
  signal(SIGINT, SIG_DFL); /* reset C-signal handler */
  lua_remove(L, base);  /* remove message handler from the stack */
  return status;
}

static int dochunk (lua_State *L, int status) {
  if (status == LUA_OK) status = docall(L, 0, 0);
  return report(L, status);
}

static int dofile (lua_State *L, const char *name) {
  return dochunk(L, luaL_loadfile(L, name));
}

static int dostring (lua_State *L, const char *s, const char *name) {
  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));
}

static void stackDump (lua_State *L) {
      int i;
      int top = lua_gettop(L);
      for (i = 1; i <= top; i++) {  /* repeat for each level */
        int t = lua_type(L, i);
        switch (t) {
    
          case LUA_TSTRING:  /* strings */
            printf("`%s'", lua_tostring(L, i));
            break;
    
          case LUA_TBOOLEAN:  /* booleans */
            printf(lua_toboolean(L, i) ? "true" : "false");
            break;
    
          case LUA_TNUMBER:  /* numbers */
            printf("%g", lua_tonumber(L, i));
            break;
    
          default:  /* other values */
            printf("%s", lua_typename(L, t));
            break;
    
        }
        printf("  ");  /* put a separator */
      }
      printf("\n");  /* end the listing */
    }

/* ************************************************* */
/* Let's write some functions that use the Rosie API */
/* ************************************************* */

static int initialize(lua_State *L) {

     int status;
     int stkpos = lua_gettop(L);
     
     const char *setup = "ROSIE_HOME=\"/Users/jjennings/Work/Dev/rosie-pattern-language\"; SCRIPTNAME=\"foo\"";
     status = dostring (L, setup, "this is a test");
     report(L, status);
     if (status != LUA_OK) return EXIT_FAILURE;
  
     status = dofile(L, "/Users/jjennings/Work/Dev/rosie-pattern-language/src/bootstrap.lua");
     report(L, status);
     if (status != LUA_OK) return EXIT_FAILURE;

     lua_getglobal(L, "bootstrap");
     lua_insert(L, 1);
     status = lua_pcall(L, 0, 0, 0);
     if (status != LUA_OK)
	  l_message(progname, lua_pushfstring(L, "error calling 'bootstrap' (%s)",
					      lua_tostring(L, -1)));
     report(L, status);
     if (status != LUA_OK) return EXIT_FAILURE;
  
     lua_getglobal(L, "require");
     lua_pushstring(L, "repl");
     status = docall(L, 1, 1);  /* call 'require(name)' */
     lua_pop(L, 1);	     /* pop result of require */
     report(L, status);
     if (status != LUA_OK) return EXIT_FAILURE;

     lua_getglobal(L, "require");
     lua_pushstring(L, "api");
     status = docall(L, 1, 1);  /* call 'require(name)' */
     lua_pop(L, 1);	     /* pop result of require */
     report(L, status);
     if (status != LUA_OK) return EXIT_FAILURE;

     if (lua_gettop(L)!=stkpos)
	  printf("WARNING: after initialization, top should be %d but was %d\n",
		 stkpos,
		 lua_gettop(L));

     return EXIT_SUCCESS;
}

/* After tuning these, move them to header file */
/* #define API_MAX_ARGS 5 */
/* #define API_MAX_ARG_LEN 500 */

int rosie_api(lua_State *L, const char *name, ...) {

     va_list args;
     char *arg;
     int top, base;
     
     int nargs = 1;		   /* get this later from a table */

     va_start(args, name);	   /* setup variadic arg processing */

     printf("Stack at start of rosie_api:\n");
     stackDump(L);
     base = lua_gettop(L);			    /* save top pointer */

     /* Optimize later: memoize stack value of fcn for each api call to avoid this lookup? */

     lua_getglobal(L, "api");
     lua_getfield(L, -1 , name);                    /* -1 is stack top, i.e. api table */

     /* Later: insert a check HERE to ensure the value we get is a function */

     for (int i = 1; i <= nargs; i++) {
	  arg = va_arg(args, char *);   /* get the next arg */
	  lua_pushstring(L, arg);	/* push it */
     }

     lua_call(L, nargs, LUA_MULTRET); 
     if (lua_isboolean(L, base+1) != 0) {
	  l_message(progname, lua_pushfstring(L, "api error: calling %s and first return value not a boolean", name));
	  exit(-1);
     }

     int ok = lua_toboolean(L, base+1);
     if (!ok) {
	       printf("== In api error handler ==\n");
	       stackDump(L);
	       /* l_message((const char *)'\0', lua_pushfstring(L, "error calling %s: %s", name, lua_tostring(L, -1))); */
	       l_message(progname, lua_pushfstring(L, "error getting engine: %s", lua_tostring(L, -2)));
	       exit(-1);
	  }

     /* old error handler */
     lua_pushboolean(L, 1);			    /* push true */
     if (lua_compare(L, -1, -3, LUA_OPEQ) != 1) {
	  /* a false return value should be accompanied by a Rosie API error message */
	  /* TODO: Use that instead of this message */
	  printf("*******************************************************\n");
	  stackDump(L);
	  lua_pop(L, 1);       /* pop the true value we pushed for comparison */
	  /* l_message((const char *)'\0', lua_pushfstring(L, "error calling %s: %s", name, lua_tostring(L, -1))); */
	  l_message(progname, lua_pushfstring(L, "error getting engine: %s", lua_tostring(L, -2)));
	  exit(-1);
     }

     lua_pop(L, 1);       /* pop the api status return value (boolean) */
     top = lua_gettop(L); 
     for (int i=1; i <= (top - 2); i++) {
	  lua_replace(L, 1);    /* move current top elt (an api retval) to bottom of stack */
     }
     lua_settop(L, (top - 2));  /* trash all but the rosie api retval */


     printf("Stack at end of rosie_api:\n");
     stackDump(L);

     va_end(args);
     
     return LUA_OK;
}

     

// $SCRIPT_PATH/bin/lua -e "ROSIE_HOME=\"$SCRIPT_PATH\"; SCRIPTNAME=\"$0\"" $SCRIPT_PATH/src/run.lua "$@"

int main (int argc, char **argv) {
  int status;
  lua_State *L = luaL_newstate();  /* create state */
  if (L == NULL) {
    l_message(argv[0], "cannot create state: not enough memory");
    return EXIT_FAILURE;
  }

  luaL_checkversion(L);  /* check that interpreter has correct version ??? */

  luaL_openlibs(L);  /* open standard libraries */

  if (initialize(L)==EXIT_FAILURE) return EXIT_FAILURE;

  char *name = malloc(sizeof(char) * 100);
  strcpy(name, "REPL ENGINE");
  status = rosie_api(L, "new_engine", name);	    /* leaves engine id on stack */

  lua_getglobal(L, "repl");	  /* push repl fcn */
  lua_pushvalue(L, -2);		  /* copy engine id to top of stack */
  docall(L, 1, 1);		  /* call repl(eid) */
  report(L, status);
  if (status != LUA_OK) {
       l_message(progname, lua_pushfstring(L, "error starting repl: %s", lua_tostring(L, -1)));
       return EXIT_FAILURE;
  }

  lua_close(L);
  return (status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;

}

