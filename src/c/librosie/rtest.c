/*  -*- Mode: C/l; -*-                                                       */
/*                                                                           */
/* rosie.c      Create a Lua state, load Rosie, expose the Rosie API         */
/*                                                                           */
/*  Â© Copyright IBM Corporation 2016.                                        */
/*  LICENSE: MIT License (https://opensource.org/licenses/mit-license.html)  */
/*  AUTHOR: Jamie A. Jennings                                                */


/* 
 * Based on src/lua.c from the open source Lua 5.3.2 distribution under MIT license
 *
 * Right now, this is just hacking around to learn my way around using the Lua state.
 *
 */


#define rosie_c

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include "lauxlib.h"
#include "lualib.h"

#define PROGNAME		"rosie"

static lua_State *globalL = NULL;
static const char *progname = PROGNAME;

/*
 * Hook set by signal function to stop the interpreter.
 */
static void lstop (lua_State *L, lua_Debug *ar) {
  (void)ar;  /* unused arg. */
  lua_sethook(L, NULL, 0, 0);  /* reset hook */
  luaL_error(L, "interrupted!");
}

/*
** Function to be called at a C signal. Because a C signal cannot
** just change a Lua state (as there is no proper synchronization),
** this function only sets a hook that, when called, will stop the
** interpreter.
*/
static void laction (int i) {
  signal(i, SIG_DFL); /* if another SIGINT happens, terminate process */
  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
}

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char *pname, const char *msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message(progname, msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}

/*
** Message handler used to run all chunks
*/
static int msghandler (lua_State *L) {
  const char *msg = lua_tostring(L, 1);
  if (msg == NULL) {  /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
      return 1;  /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                               luaL_typename(L, 1));
  }
  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
  return 1;  /* return the traceback */
}

/*
** Interface to 'lua_pcall', which sets appropriate message function
** and C-signal handler. Used to run all chunks.
*/
static int docall (lua_State *L, int narg, int nres) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, msghandler);  /* push message handler */
  lua_insert(L, base);  /* put it under function and args */
  globalL = L;  /* to be available to 'laction' */
  signal(SIGINT, laction);  /* set C-signal handler */
  status = lua_pcall(L, narg, nres, base);
  signal(SIGINT, SIG_DFL); /* reset C-signal handler */
  lua_remove(L, base);  /* remove message handler from the stack */
  return status;
}

static int dochunk (lua_State *L, int status) {
  if (status == LUA_OK) status = docall(L, 0, 0);
  return report(L, status);
}

static int dofile (lua_State *L, const char *name) {
  return dochunk(L, luaL_loadfile(L, name));
}

static int dostring (lua_State *L, const char *s, const char *name) {
  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));
}

/* ************************************************* */
/* Let's write some functions that use the Rosie API */
/* ************************************************* */

static int initialize(lua_State *L) {

     int status;
     int stkpos = lua_gettop(L);
     
     const char *setup = "ROSIE_HOME=\"/Users/jjennings/Work/Dev/rosie-pattern-language\"; SCRIPTNAME=\"foo\"";
     status = dostring (L, setup, "this is a test");
     report(L, status);
     if (status != LUA_OK) return EXIT_FAILURE;
  
     status = dofile(L, "/Users/jjennings/Work/Dev/rosie-pattern-language/src/bootstrap.lua");
     report(L, status);
     if (status != LUA_OK) return EXIT_FAILURE;

     lua_getglobal(L, "bootstrap");
     lua_insert(L, 1);
     status = lua_pcall(L, 0, 0, 0);
     if (status != LUA_OK)
	  l_message(progname, lua_pushfstring(L, "error calling 'bootstrap' (%s)",
					      lua_tostring(L, -1)));
     report(L, status);
     if (status != LUA_OK) return EXIT_FAILURE;
  
     lua_getglobal(L, "require");
     lua_pushstring(L, "repl");
     status = docall(L, 1, 1);  /* call 'require(name)' */
     lua_pop(L, 1);	     /* pop result of require */
     report(L, status);
     if (status != LUA_OK) return EXIT_FAILURE;

     lua_getglobal(L, "require");
     lua_pushstring(L, "api");
     status = docall(L, 1, 1);  /* call 'require(name)' */
     lua_pop(L, 1);	     /* pop result of require */
     report(L, status);
     if (status != LUA_OK) return EXIT_FAILURE;

     if (lua_gettop(L)!=stkpos)
	  printf("WARNING: after initialization, top should be %d but was %d\n",
		 stkpos,
		 lua_gettop(L));

     return EXIT_SUCCESS;
}

/* After tuning these, move them to header file */
/* #define API_MAX_ARGS 5 */
/* #define API_MAX_ARG_LEN 500 */

int rosie_api(lua_State *L, const char *name, ...) {

     va_list args;
     int status;
     char *arg;
     
     va_start(args, name);	   /* setup variadic arg processing */
     arg = va_arg(args, char *);   /* get the first arg */

     /* Optimize later: memoize stack value of fcn for each api call to avoid this lookup? */

     lua_getglobal(L, "api");
     lua_getfield(L, -1 , name);                    /* -1 is stack top, i.e. api table */
     /* insert a check HERE for value is a function */

     lua_pushstring(L, arg); 
     status = docall(L, 1, 2);                      /* call 'api.new_engine(name)' 1 arg, 2 results */
     report(L, status);
     if (status != LUA_OK) return EXIT_FAILURE;

     lua_pushboolean(L, 1);			    /* push true */
     if (lua_compare(L, -1, -3, LUA_OPEQ) != 1) {
	  l_message(progname, lua_pushfstring(L, "error getting engine: %s", lua_tostring(L, -2)));
	  return EXIT_FAILURE;
     }

     lua_pop(L, 1);				    /* remove the true we pushed */

     va_end(args);
     
     return LUA_OK;
}

     

// $SCRIPT_PATH/bin/lua -e "ROSIE_HOME=\"$SCRIPT_PATH\"; SCRIPTNAME=\"$0\"" $SCRIPT_PATH/src/run.lua "$@"

int main (int argc, char **argv) {
  int status;
  lua_State *L = luaL_newstate();  /* create state */
  if (L == NULL) {
    l_message(argv[0], "cannot create state: not enough memory");
    return EXIT_FAILURE;
  }

  luaL_checkversion(L);  /* check that interpreter has correct version ??? */

  luaL_openlibs(L);  /* open standard libraries */

  if (initialize(L)==EXIT_FAILURE) return EXIT_FAILURE;

  char *name = malloc(sizeof(char) * 100);
  strcpy(name, "REPL ENGINE");
  status = rosie_api(L, "new_engine", name);

  lua_setglobal(L, "eid");			    /* save engine id */ 
  lua_pop(L, 1);				    /* pop the ok returned by new_engine */

  lua_getglobal(L, "repl");	  /* push repl fcn */
  lua_getglobal(L, "eid");	  /* push engine id */
  docall(L, 1, 1);		  /* call repl(eid) */
  report(L, status);
  if (status != LUA_OK) {
       l_message(progname, lua_pushfstring(L, "error starting repl: %s", lua_tostring(L, -1)));
       return EXIT_FAILURE;
  }

  lua_close(L);
  return (status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;

}

