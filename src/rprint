#!/bin/bash
_=[[ exec lua "$0" "$@" ]]

-- rprint: rosie output printer (does anyone remember awk?  anyone?  Bueller?  Bueller?)
--
-- Reads from standard input.
-- Options:
--   none yet

-- EXAMPLE:
--
-- rosie -encode json csv.pipe doc/data/csv/sample_pipe.csv | rprint 't={}; for k,v in ipairs($0.subs) do name,body=next(v); t[k]=body.text; end; print(table.concat(t, ","))'
    -- 2011-11-11,X12334,customerdetails 
    -- Bob,Dyson,true,23,"23|456",0,"1|543|543.36","""Interstate 80 Revisted""" 
    -- Jimmy,Pace, 
    -- Saul,McCartney,false,67,"89|125","4|324|307.5","986|545.12" 
    -- Elvis,John, 
    -- Eric,Clayton,true,461,"33|101",1.11,100.01,"\"Greatest Hits\"" 


-- EXAMPLE:
-- 
-- rosie -encode json basic.matchall /etc/resolv.conf | rprint 'println(NR,$0); for i=1,NF do printf("%q is %s\n",$i, $i.name); end'
    -- 1 # 
    -- "#" is basic.punctuation
    --
    -- 2 # Mac OS X Notice 
    -- "#" is basic.punctuation
    -- "Mac" is common.word
    -- "OS" is common.maybe_identifier
    -- "X" is common.maybe_identifier
    -- "Notice" is common.word
    --
    -- 3 # 
    -- "#" is basic.punctuation
    --
    -- 4 # This file is not used by the host name and address resolution 
    -- "#" is basic.punctuation
    -- "This" is common.word
    -- "file" is common.word
    -- "is" is common.word
    -- "not" is common.word
    -- "used" is common.word
    -- "by" is common.word
    -- "the" is common.word
    -- "host" is common.word
    -- "name" is common.word
    -- "and" is common.word
    -- "address" is common.word
    -- "resolution" is common.word
    --
    -- 5 # or the DNS query routing mechanisms used by most processes on 
    -- "#" is basic.punctuation
    -- "or" is common.word
    -- "the" is common.word
    -- "DNS" is common.maybe_identifier
    -- "query" is common.word
    -- "routing" is common.word
    -- "mechanisms" is common.word
    -- "used" is common.word
    -- "by" is common.word
    -- "most" is common.word
    -- "processes" is common.word
    -- "on" is common.word
    --
    -- 6 # this Mac OS X system. 
    -- "#" is basic.punctuation
    -- "this" is common.word
    -- "Mac" is common.word
    -- "OS" is common.maybe_identifier
    -- "X" is common.maybe_identifier
    -- "system" is common.word
    -- "." is basic.punctuation
    --
    -- 7 # 
    -- "#" is basic.punctuation
    --
    -- 8 # This file is automatically generated. 
    -- "#" is basic.punctuation
    -- "This" is common.word
    -- "file" is common.word
    -- "is" is common.word
    -- "automatically" is common.word
    -- "generated" is common.word
    -- "." is basic.punctuation
    --
    -- 9 # 
    -- "#" is basic.punctuation
    --
    -- 10 search nc.rr.com 
    -- "search" is common.word
    -- "nc.rr.com" is basic.network_patterns
    --
    -- 11 nameserver 10.0.1.1 
    -- "nameserver" is common.word
    -- "10.0.1.1" is basic.network_patterns
    --
    -- 12 nameserver 2606:a000:1120:8152:2f7:6fff:fed4:dc1f 
    -- "nameserver" is common.word
    -- "2606" is common.number
    -- ":" is basic.punctuation
    -- "a000" is common.number
    -- ":" is basic.punctuation
    -- "1120" is common.number
    -- ":" is basic.punctuation
    -- "8152" is common.number
    -- ":" is basic.punctuation
    -- "2f7" is common.number
    -- ":" is basic.punctuation
    -- "6fff" is common.number
    -- ":" is basic.punctuation
    -- "fed4" is common.number
    -- ":" is basic.punctuation
    -- "dc1f" is common.number


ROSIE_HOME = os.getenv("ROSIE_HOME")
if not ROSIE_HOME then
   ROSIE_HOME = "."
end

-- Restrict Lua's search for modules and shared objects to just the Rosie install directory
package.path = ROSIE_HOME .. "/bin/?.luac;" .. ROSIE_HOME .. "/src/?.lua"
package.cpath = ROSIE_HOME .. "/lib/?.so"

json = require "cjson"
util = require "util"
require "list"

orig = {}
orig.print = print;

OFS = " "					    -- output field separator
ORS = "\n"					    -- output record separator
NR = 0;

function print(...)
   for _,v in ipairs({...}) do
      io.write(tostring(v), OFS)
   end
end   

function println(...)
   print(...)
   io.write(ORS)
end

function printf(fmt, ...)
   io.write(string.format(fmt, ...))
end

function quote(arg)
   return string.format("%q", arg)
end

local args = {...}
local script = args[1]

function transform(s, table_name)
   -- This is a cheap hack for proof-of-concept testing.
   local ex = s;
   -- Replace $anything NOT followed by a dot with $anything.text
   ex = ex:gsub("%$(%w+)([^.])", table_name.."[%1].text%2")
   -- Replace $xyz with t[xyz]
   ex = ex:gsub("%$(%w+)", table_name.."[%1]")
   return ex
end

transformed = transform(script, "LINE")
local f, err = load(transformed, "rprint script", "t")
if (not f) then
   error(string.format("Failed to compile script: %q\nExpanded script is: %q\nError: %s",
		       script,
		       transformed,
		       err),
	 0)
end

l = io.stdin:read("l")
while l do
   NR = NR + 1
   t = {};
   ok, thing = pcall(json.decode, l)
   if not ok then
      io.stdout:write(l, "\n")
   elseif type(thing)=="table" then
      name, t[0] = next(thing)
      t[0].name = name
      LINE=t
      for i,s in ipairs(t[0].subs) do name, t[i] = next(s); t[i].name = name; end
      NF = #t
      f()
   elseif thing==json.null then
      io.stdout:write("null\n")
   else
      io.stdout:write(tostring(thing), "\n")
   end
   io.stdout:write(ORS)
   l = io.stdin:read("l")
end -- while
