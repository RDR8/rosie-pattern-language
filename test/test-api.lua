---- -*- Mode: Lua; -*- 
----
---- test-api.lua
----
---- (c) 2016, Jamie A. Jennings
----

json = require "cjson"

if not color_write then
   color_write = function(channel, ignore_color, ...)
		    for _,v in ipairs({...}) do
		       channel:write(v)
		    end
		 end
end

function red_write(...)
   local str = ""
   for _,v in ipairs({...}) do str = str .. tostring(v); end
   color_write(io.stdout, "red", str)
end

local count = 0
local fail_count = 0
local heading_count = 0
local subheading_count = 0
local messages = {}
local current_heading = "Heading not assigned"
local current_subheading = "Subheading not assigned"

function check(thing, message)
   count = count + 1
   heading_count = heading_count + 1
   subheading_count = subheading_count + 1
   if not (thing) then
      red_write("X")
      table.insert(messages, {h=current_heading or "Heading unassigned",
			      sh=current_subheading or "",
			      shc=subheading_count,
			      hc=heading_count,
			      c=count,
			      m=message or ""})
      fail_count = fail_count + 1
   end
   io.stdout:write(".")
end

function heading(label)
   heading_count = 0
   subheading_count = 0
   current_heading = label
   current_subheading = ""
   io.stdout:write("\n", label, " ")
end

function subheading(label)
   subheading_count = 0
   current_subheading = label
   io.stdout:write("\n\t", label, " ")
end

function ending()
   io.stdout:write("\n\n** TOTAL ", tostring(count), " tests attempted.\n")
   if fail_count == 0 then
      io.stdout:write("** All tests passed.\n")
   else
      io.stdout:write("** ", tostring(fail_count), " tests failed:\n")
      for _,v in ipairs(messages) do
	 red_write(v.h, ": ", v.sh, ": ", "#", v.shc, " ", v.m, "\n")
      end
   end
end

----------------------------------------------------------------------------------------

heading("Require api")
api = require "api"

check(type(api)=="table")
check(api.VERSION)
check(type(api.VERSION=="string"))

heading("Engine")
subheading("new_engine")
check(type(api.new_engine)=="function")
ok, eid = api.new_engine("hello")
check(ok)
check(type(eid)=="string")
ok, eid2 = api.new_engine("hello")
check(ok)
check(type(eid2)=="string")
check(eid~=eid2, "engine ids (as generated by Lua) must be unique")

subheading("ping_engine")
check(type(api.ping_engine)=="function")
ok, name = api.ping_engine(eid)
check(ok)
check(name=="hello")
ok, msg = api.ping_engine()
check(not ok)
check(msg=="Argument error: engine id not a string")
ok, msg = api.ping_engine("foobar")
check(not ok)
check(msg=="Argument error: invalid engine id")

subheading("delete_engine")
check(type(api.delete_engine)=="function")
ok = api.delete_engine(eid2)
check(ok)
ok = api.delete_engine(eid2)
check(ok, "idempotent delete function")

ok, msg = api.ping_engine(eid2)
check(not ok)
check(msg=="Argument error: invalid engine id")
check(api.ping_engine(eid), "other engine with same name still exists")

subheading("get_env")
check(type(api.get_env)=="function")
ok, env = api.get_env(eid)
check(ok)
check(type(env)=="string", "environment is returned as a JSON string")
j = json.decode(env)
check(type(j)=="table")
check(j["."].type=="alias", "env contains built-in alias '.'")
check(j["$"].type=="alias", "env contains built-in alias '$'")
ok, msg = api.get_env()
check(not ok)
check(msg=="Argument error: engine id not a string")
ok, msg = api.get_env("hello")
check(not ok)
check(msg=="Argument error: invalid engine id")

subheading("get_definition")
check(type(api.get_definition)=="function")
ok, def = api.get_definition(eid, "$")
check(ok, "can get a definition for '$'")
check(def=="alias $ = // built-in RPL pattern //")

heading("Load")
subheading("load_string")
check(type(api.load_string)=="function")


subheading("load_file")
check(type(api.load_file)=="function")

subheading("load_manifest")
check(type(api.load_manifest)=="function")

heading("Match")



ending()




       

